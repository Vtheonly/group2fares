<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dynamic Factory Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0e1117; font-family: sans-serif; }
        #tooltip {
            position: absolute; display: none; padding: 10px;
            background: rgba(0,0,0,0.8); color: white; border: 1px solid #00d2ff;
            pointer-events: none; border-radius: 4px; font-size: 12px;
            z-index: 1000;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00d2ff; font-weight: bold; font-size: 20px;
        }
    </style>
    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
            }
        }
    </script>
</head>
<body>
    <div id="loading">CONNECTING TO PIPELINE...</div>
    <div id="tooltip"></div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import TWEEN from '@tweenjs/tween.js';

        // 1. DYNAMIC DATA HANDLING
        let machineData = {}; // Synced from Streamlit

        // 2. SCENE SETUP
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0e1117);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 100, 10000000);
        camera.position.set(100000, 100000, 100000);
        
        const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true, powerhouse: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 2.5; // VERY BRIGHT
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // INDUSTRIAL LIGHTING RIG
        scene.add(new THREE.AmbientLight(0xffffff, 2.0)); 
        
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        scene.add(hemiLight);

        const sun = new THREE.DirectionalLight(0xffffff, 3.0);
        sun.position.set(50000, 100000, 50000);
        scene.add(sun);

        const fill = new THREE.DirectionalLight(0xffffff, 2.0);
        fill.position.set(-50000, 50000, -50000);
        scene.add(fill);

        // POST PROCESSING
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
        outlinePass.edgeStrength = 10;
        outlinePass.edgeGlow = 1;
        outlinePass.visibleEdgeColor.set('#00ff88');
        composer.addPass(outlinePass);

        // 3. LOAD DYNAMIC MODEL
        const params = new URLSearchParams(window.location.search);
        const modelUrl = params.get('model_url'); 

        if (modelUrl) {
            console.log("VIEWER: Loading model ->", modelUrl);
            new GLTFLoader().load(modelUrl, (gltf) => {
                scene.add(gltf.scene);
                document.getElementById('loading').style.display = 'none';
                
                // Adjust materials to be brighter if they are standard
                gltf.scene.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.envMapIntensity = 2.0;
                    }
                });

                const box = new THREE.Box3().setFromObject(gltf.scene);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                console.log("VIEWER: Model Ready. Size:", size);
                
                controls.target.copy(center);
                camera.position.set(center.x + size.x*1.5, center.y + size.y*1.5, center.z + size.z*1.5);
                controls.update();
            }, (xhr) => {
                if (xhr.total > 0) {
                    const percent = Math.round(xhr.loaded / xhr.total * 100);
                    document.getElementById('loading').innerText = `LOADING: ${percent}%`;
                }
            }, (err) => {
                document.getElementById('loading').innerText = "LOAD ERROR: " + err;
            });
        }

        // 4. INTERACTION & ZOOM
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');
        let hoveredObj = null;
        let originalEmissive = new THREE.Color();

        function focusCamera(machineId) {
            console.log("VIEWER: focusCamera triggered for:", machineId);
            
            // 1. Try pre-computed camera coordinates first (most reliable)
            const data = machineData[machineId];
            if (data && data.camera) {
                console.log("VIEWER: Using pre-computed camera coords for:", machineId);
                const camCoords = data.camera;
                
                // Stop any current tweens
                TWEEN.removeAll();
                
                // Highlight the object if found
                let obj = scene.getObjectByName(machineId);
                if (!obj) {
                    scene.traverse(node => {
                        if (node.isMesh && (node.name === machineId || node.name.includes(machineId))) {
                            obj = node;
                        }
                    });
                }
                if (obj) outlinePass.selectedObjects = [obj];
                
                // Tween to pre-computed position
                new TWEEN.Tween(camera.position)
                    .to({
                        x: camCoords.position.x,
                        y: camCoords.position.y,
                        z: camCoords.position.z
                    }, 2000)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .start();
                
                new TWEEN.Tween(controls.target)
                    .to({
                        x: camCoords.target.x,
                        y: camCoords.target.y,
                        z: camCoords.target.z
                    }, 2000)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .onUpdate(() => controls.update())
                    .start();
                
                return;
            }
            
            // 2. Fallback: Find Node and compute on-the-fly
            console.log("VIEWER: No pre-computed coords, searching scene for:", machineId);
            let obj = scene.getObjectByName(machineId);
            if (!obj) {
                scene.traverse(node => {
                    if (node.isMesh && (node.name === machineId || node.name.includes(machineId))) {
                        obj = node;
                    }
                });
            }

            if (obj) {
                console.log("VIEWER: Node found, computing camera position");
                outlinePass.selectedObjects = [obj];

                const box = new THREE.Box3().setFromObject(obj);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                
                // Adaptive zoom distance
                const zoomDist = maxDim * 2.5;

                // Stop any current tweens
                TWEEN.removeAll();

                new TWEEN.Tween(camera.position)
                    .to({
                        x: center.x + zoomDist, 
                        y: center.y + zoomDist, 
                        z: center.z + zoomDist
                    }, 2000)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .start();
                
                new TWEEN.Tween(controls.target)
                    .to({x: center.x, y: center.y, z: center.z}, 2000)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .onUpdate(() => controls.update())
                    .start();
            } else {
                console.error("VIEWER: focusCamera failed - Node not found in scene:", machineId);
            }
        }

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            const hit = intersects.find(i => i.object.isMesh && i.object.name !== 'floor' && !i.object.name.startsWith('pipe'));
            
            if (hit) {
                const obj = hit.object;
                const name = obj.name;
                const data = machineData[name];

                // Check if we hit a new object
                if (hoveredObj !== obj) {
                    if (hoveredObj && hoveredObj.material && hoveredObj.material.emissive) {
                        hoveredObj.material.emissive.copy(originalEmissive);
                    }
                    hoveredObj = obj;
                    outlinePass.selectedObjects = [obj];
                    
                    if (obj.material && obj.material.emissive) {
                        originalEmissive.copy(obj.material.emissive);
                        obj.material.emissive.setHex(0x004466); // Subtle blue glow
                    }
                }

                tooltip.style.display = 'block';
                tooltip.style.left = e.clientX + 15 + 'px';
                tooltip.style.top = e.clientY + 15 + 'px';
                
                if (data) {
                    let metricHtml = Object.entries(data.metrics)
                        .map(([k,v]) => `<div>${k}: <b style="color:#00ff88">${v}</b></div>`)
                        .join('');
                    tooltip.innerHTML = `<strong>${data.display_name}</strong><br>${metricHtml}`;
                } else {
                    tooltip.innerHTML = `ID: ${name}`;
                }
            } else {
                if (hoveredObj && hoveredObj.material && hoveredObj.material.emissive) {
                    hoveredObj.material.emissive.copy(originalEmissive);
                }
                hoveredObj = null;
                outlinePass.selectedObjects = [];
                tooltip.style.display = 'none';
            }
        });

        // 5. MESSAGE LISTENER FOR DASHBOARD COMMUNICATION
        window.addEventListener('message', function(event) {
            console.log("VIEWER: Received message:", event.data);
            
            if (event.data && event.data.type === 'FOCUS') {
                const machineId = event.data.data;
                console.log("VIEWER: FOCUS command received for:", machineId);
                focusCamera(machineId);
            }
            
            if (event.data && event.data.type === 'SYNC_DATA') {
                machineData = event.data.data;
                console.log("VIEWER: SYNC_DATA received, machines:", Object.keys(machineData).length);
            }
        });

        function animate(t) {
            requestAnimationFrame(animate);
            TWEEN.update(t);
            controls.update();
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
